// Generated by CoffeeScript 1.10.0
var Kckr, fs, helpers, path, wait,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

fs = require('fs');

path = require('path');

helpers = require('./helpers');

wait = function(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

Kckr = (function() {
  function Kckr(options) {
    this.remove_source = bind(this.remove_source, this);
    this.unwatch_dir = bind(this.unwatch_dir, this);
    this.watch_dir = bind(this.watch_dir, this);
    this.watch = bind(this.watch, this);
    this.kickoff = bind(this.kickoff, this);
    this.validate = bind(this.validate, this);
    var defaults, j, len, ref, source;
    options || (options = {});
    defaults = {
      pattern: /.*/,
      sources: [],
      callback: function() {},
      verbose: false,
      kickonce: false
    };
    options = helpers.merge(defaults, options);
    this.sources = options.sources;
    this.not_sources = [];
    this.fn = options.callback;
    this.re = options.pattern;
    this.verbose = options.verbose;
    this.kickonce = options.kickonce;
    ref = this.sources;
    for (j = 0, len = ref.length; j < len; j++) {
      source = ref[j];
      this.kickoff(source, true, path.normalize(source), true);
    }
  }

  Kckr.prototype.validate = function(source) {
    return !!source.match(this.re);
  };

  Kckr.prototype.kickoff = function(source, top_level, base, first_run) {
    if (first_run == null) {
      first_run = false;
    }
    return fs.stat(source, (function(_this) {
      return function(err, stats) {
        if (err && err.code !== 'ENOENT') {
          throw err;
        }
        if ((err != null ? err.code : void 0) === 'ENOENT') {
          return;
        }
        if (stats.isDirectory()) {
          if (!_this.kickonce) {
            _this.watch_dir(source, base);
          }
          if (first_run && _this.verbose) {
            console.log("Watching dir: " + source);
          }
          return fs.readdir(source, function(err, files) {
            var file, index, j, len, results;
            if (err && err.code !== 'ENOENT') {
              throw err;
            }
            if ((err != null ? err.code : void 0) === 'ENOENT') {
              return;
            }
            files = files.map(function(file) {
              return path.join(source, file);
            });
            index = _this.sources.indexOf(source);
            [].splice.apply(_this.sources, [index, index - index + 1].concat(files)), files;
            results = [];
            for (j = 0, len = files.length; j < len; j++) {
              file = files[j];
              results.push(_this.kickoff(file, false, base, true));
            }
            return results;
          });
        } else if (top_level || (stats.isFile() && _this.validate(source))) {
          if (!_this.kickonce) {
            _this.watch(source, base);
          }
          if (_this.kickonce) {
            _this.fn(source, base);
          }
          if (first_run && _this.verbose) {
            return console.log("Watching file: " + source);
          }
        } else {
          _this.not_sources[source] = true;
          return _this.remove_source(source, base);
        }
      };
    })(this));
  };

  Kckr.prototype.watch = function(source, base) {
    var e, error, execute, rewatch, watchOpts, watch_err;
    watchOpts = {
      persistent: false,
      interval: 25
    };
    watch_err = (function(_this) {
      return function(e) {
        var error;
        if (e.code === 'ENOENT') {
          if (_this.sources.indexOf(source) === -1) {
            return;
          }
          try {
            return rewatch();
          } catch (error) {
            e = error;
            return _this.remove_source(source, base, true);
          }
        } else {
          throw e;
        }
      };
    })(this);
    execute = (function(_this) {
      return function(curr, prev) {
        if (curr.mtime > prev.mtime) {
          _this.fn(source, base);
          return rewatch();
        }
      };
    })(this);
    try {
      fs.watchFile(source, watchOpts, execute);
    } catch (error) {
      e = error;
      watch_err(e);
    }
    return rewatch = (function(_this) {
      return function() {
        fs.unwatchFile(source);
        return fs.watchFile(source, watchOpts, execute);
      };
    })(this);
  };

  Kckr.prototype.watch_dir = function(source, base) {
    var e, error, readdir_timeout, watcher;
    readdir_timeout = null;
    try {
      return watcher = fs.watch(source, (function(_this) {
        return function() {
          clearTimeout(readdir_timeout);
          return readdir_timeout = wait(25, function() {
            return fs.readdir(source, function(err, files) {
              var file, j, len, results;
              if (err) {
                if (err.code !== 'ENOENT') {
                  throw err;
                }
                watcher.close();
                return _this.unwatch_dir(source, base);
              }
              files = files.map(function(file) {
                return path.join(source, file);
              });
              results = [];
              for (j = 0, len = files.length; j < len; j++) {
                file = files[j];
                if (_this.sources.some(function(s) {
                  return s.indexOf(file) >= 0;
                })) {
                  continue;
                }
                _this.sources.push(file);
                results.push(_this.kickoff(file, false, base));
              }
              return results;
            });
          });
        };
      })(this));
    } catch (error) {
      e = error;
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
  };

  Kckr.prototype.unwatch_dir = function(source, base) {
    var file, j, len, prev_sources, to_remove;
    prev_sources = this.sources.slice(0, this.sources.length);
    to_remove = (function() {
      var j, len, ref, results;
      ref = this.sources;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        file = ref[j];
        if (file.indexOf(source) >= 0) {
          results.push(file);
        }
      }
      return results;
    }).call(this);
    for (j = 0, len = to_remove.length; j < len; j++) {
      file = to_remove[j];
      remove_source(file, base, true);
    }
    if (!this.sources.some((function(_this) {
      return function(s, i) {
        return prev_sources[i] !== s;
      };
    })(this))) {

    }
  };

  Kckr.prototype.remove_source = function(source, base) {
    var index;
    index = this.sources.indexOf(source);
    return this.sources.splice(index, 1);
  };

  return Kckr;

})();

exports.Kckr = Kckr;
